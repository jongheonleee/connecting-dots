# 기술적 고민 막 적어 놓기 -> 프로젝트 소개 글에 언급하기 

### 0. MyBatis, JPA 모두 적용 가능한 프로젝트 설계
- 어댑터 패턴과 추상 계층 활용하여 적용
- 스프링의 PSA(서비스 추상화) 방식을 모티브로함

### 1. 조인 대신 상관쿼리를 활용하여 성능 이점 얻기
- 게시판 조회 형태가 바뀜
- 그 과정에서 조인해야 하는 테이블은 총 2개 > 게시판 & 댓글 & 이미지
- 이를 조인해버리는 것이 아닌 상관쿼리 활용하여 성능의 이점을 얻으려고 노력함(서브 쿼리 캐싱 기대)
- 상관쿼리를 활용해도 SQL 옵티마이저가 서브쿼리 Unnesting을 통해 조인 문으로 변환하는 경우도 있음 

### 2. 베스트 관련 게시글 조회
- 테이블 설계시 선분 이력으로 집계 테이블 형식 처럼 설계
- 원본 테이블을 조회하는 것이 아닌 베스트 전용 집계 테이블을 활용하게 하여 성능 이점을 얻으려고 노력함

### 3. MyBatis와 JDBC를 선택한 이유
- MyBatis는 SQL Mapper로써 SQL을 직접 작성할 수 있음
- 즉, 복잡한 SQL 쿼리를 내가 작성하며 성능 튜닝을 할 수 있음
- 또한, 현재 나의 데이터 모델링 설계 구조에 따라 여러 테이블이 정규화 되어 있기 때문에 직접 쿼리를 작성하는 것이 유리하다고 판단함
- 동적 쿼리를 생성하는 데 있어서 활용할 수 있는 기술은 JPA, JDBC가 있음
  - MyBatis는 쿼리와 자바 코드를 분리하는 구조이기에 동적쿼리를 작성하는 데에 한계가 있음
- 동적 쿼리는 DB에 저장된 값들의 조합으로 생성해야 하기 때문에 자바 문자열 결합이나 SQL 쿼리로 해당 조건절을 생성하는 것이 적합함
- 따라서 JPA가 아닌 JDBC를 선택함 
- 또한, 서브쿼리로 결과를 조회할 경우 스칼라 형태로 값을 조회하기 때문에 여러번의 서브쿼리를 날려야 하지만, 이를 SQL에서 지원하는 함수를 적절히 활용하면 하나의 쿼리문을 통해서 여러가지 형태의 값을 조회할 수 있음
- DML 처리시 그 전에 SELECT ~ FOR UPDATE를 통해 특정 행을 잠금 처리할 수 있음. 이로써 DML 처리 과정에서 다른 트랜잭션에 의해 데이터가 변경되는 것을 방지할 수 있음

### 4. 데이터 모델링
- 왜 서비스에서 정책들을 조건이나 규칙으로 분리해서 관리할까
- 모든 애플리케이션에서는 정책이 존재하며 해당 정책을 좀 더 면밀히 따지면 규칙이나 조건의 조합으로 생각할 수 있음
- 또한, 해당 데이터들도 관리 대상이므로 데이터 모델링할 때 고려함 
- 추가적으로 규칙이나 조건들을 개별적으로 저장해두면 추후에 새로운 정책을 정의하거나 기존의 정책을 변경할 때 수월하게 진행할 수 있음


--------------
밑에 부분 나중에 따로 정리하기 

### 🤔 기술적 고민과 적용과정

> ### 1. 변경에 유리한 구조 설계 -> "세부 기술로 부터 추상화" [❌(적용 계획)]
> - <img src="description/기술적고민흔적/세부DAO기술로부터추상화시키기.jpeg" height="400" width="400">
> - 현재 프로젝트에서 사용하는 DAO 기술은 MyBatis와 JPA가 있다.
> - 하지만, 두 기술은 세부 처리 내용(코드)이 다름. 이를 스프링의 PSA와 같이 추상화함
> - 즉, 세부 기술 처리 로직이 그 상위 모듈에 영향을 주지 않게 설계함
    >   - 이 과정에서 사용한 디자인 패턴은 Adapter Pattern
>   - 또한, DTO와 처리 기능을 추상화시킴
>
> - <strong>스프링의 핵심 기능 중 하나인 PSA와 유사하게 적용함</strong>

<br>
<br>

> ### 2. 넓은 범위의 테스트 작성 -> "통합 테스트/학습 테스트/단위 테스트 적용" [✅]
> - <img src="description/기술적고민흔적/테스트에대한고민.png" height="400" width="400">
> - 현재 프로젝트의 테스트 구조를 보면 크게 3가지 부분으로 나뉨
    >   - (1) integration : 통합 테스트
>   - (2) learning : 학습 테스트
>   - (3) unit : 단위 테스트
>
> - 내가 구현한 기능에 대해 "학습 테스트"를 통해 충분히 학습함. 예를들어서, 테이블 제약 조건을 위반할 경우 어떤 예외가 발생할지 학습.
> - 이를 통해, 내가 구현한 기능에 대한 이해도를 높이고 넓은 범위의 "테스트 코드"를 작성함.
> - 마지막으로 "통합 테스트"를 통해 전체 기능에 대한 검증을 함.

<br>
<br>


> ### 3. 중요한 데이터 처리는 재시도를 통한 복구 시도 -> "재시도에 대한 전략과 @Retryable을 활용함" [✅]
> - 게시글을 작성하거나 수정하는 과정은 해당 애플리케이션의 핵심 기능
> - 따라서, DB 네트워크 장애로 인해 데이터 등록이나 수정 처리가 제대로 이루어지지 않을 경우 재시도를 통해 복구함
> - 물론, 재시도를 어떻게 할지에 대한 전략을 세웠고 해당 전략에 따라 수행함
    >   - 재시도 횟수는 10 번
>   - 대기 시간은 5초
>
> - 아래 코드 참고

```java
// 추후에 첨부(코드 정리되면) 

```
<br>
<br>

> ### 4. AOP 적용 -> "특정 예외를 예외정책에 따라 정의된 애플리케이션 예외로 변환하는 과정을 AOP로 처리" [❌(적용 계획)]
>

```java
// 추후에 첨부(코드 정리되면) 

```

> ### 5. 모든 테스트 코드의 형태가 유사함[ ]
> - 서비스 테스트 코드에서 반복되는 값들이나 코드가 있음
> - 이 부분 템플릿 메서드 패턴을 활용해서 중복 코드 제거해서 코드 활용성 높이기 



### 6. Mockists를 활용한 테스트는 과연 좋은 것인가?

- sut의 내부 구현이 테스트 코드로 노출됨
- 이는 정보 은닉을 위반함
- 이로 인해 변경에 유리한 코드가 아님
- 즉, 내부 구현이 달라질 때 마다 테스트 코드도 동일하게 수정해야함
- 물론 Mockists를 활용하면, 내부 로직을 세세하게 검토할 수 있다는 것은 의미있음 

### 7. TDD를 적용하면 좋은 점

- TDD의 사이클링을 알아야함
  - RED : 실패하는 테스트 코드 추가
  - GREEN : 실패하는 테스트를 통과하게끔 구현. 이때 중요한 것은 실패하는 테스트 코드 통과하게끔만 코드가 구현되야함
  - REFACTOR : 모든 테스트가 통과된다는 전제하에 코드 베이스 정리나 내부 구현 설계를 개선함

- 목적지향적 프로그래밍이 가능하여 좀 더 효율적으로 개발할 수 있음
- 또한, 테스트 코드를 먼저 작성하게 되면, 내가 구현하려는 기능에 대한 이해도를 높일 수 있음
- 그리고 리팩토링을 할 때 테스트 코드를 기반으로 진행하기 때문에 코드의 본래 의미가 변질되는 부분을 피드백 받을 수 있음

### 9. 재시도 복구를 테스트 할 때 문제점
- 재시도 복구 과정에서 걸리는 시간을 기다려야함
- 즉, 테스트 코드 실행이 느려짐 
- 이를 해결하기 위해 reflextion을 활용했지만, 실패함... 


### 10. 개인적으로 이쁘다고 생각하는 코드 

```java


@Override
@Transactional(
        rollbackFor = Exception.class,
        propagation = Propagation.REQUIRED
)
public void modify(final ReportRequest request) {
    checkReportExistsForUpdate(request.getRno());
    if (!reportProcessDetailsService.canChangeReport(request.getRno())) {
        log.error("[REPORT] 리포트 처리가 진행되었기 때문에 수정을 할 수 없습니다. rno: {}", request.getRno());
        throw new ReportAlreadyProcessedException();
    }

    var dto = request.toDto(formatter.getCurrentDateFormat(), formatter.getLastDateFormat(), formatter.getManagerSeq());
    checkApplied(1, reportRepository.update(dto));
    updateOldChangeHistoryAndCreateNewChangeHistory(request);
}


```

- 오브젝트 간의 소통이 원할하게 이루어지고 있음
- 코드 가독성 또한 좋음. 앞으로 이렇게 코드를 작성하려고 노력하자 !


### 11. SELECT ~~ FOR UPDATE를 통한 행 잠금 처리

- 업데이트나 삭제 처리시에 다른 트랜잭션이 끼어들 수 있음
- 이를 방지하기 위해 SELECT ~~ FOR UPDATE를 통해 특정 행을 잠금 처리함(행 잠금은 기본적으로 테이블에도 락 걸림)
